###  动态规划

这章记录我的动态规划之路。

相信大家学习动态规划的时候都感觉这个技巧好神奇，好有用。

#### 简介

相信什么是动态规划应该不需要我这里多赘述了。我这里想写写我自己的个人心得体会，作为自己的一个学习记录，看到这里的朋友，也可以交流思考。

#### 解决问题的思考过程

我们应该来一道题作为例子：

- leetcode 300 最长上升子序列

这个题目的要求是，给我们一个**无序**的整数数组，找到其中最长的递增**子序列**。 我这里把关键字给高亮了，注意一点，子序列是数组的一个子集，可以不用连续，子串则必须连续。

---

最初的思考过程，相信很多人直接暴力来搜。这里给个大概的代码模版如下：

```java
int max = 0
for (int i = 0; i < arr.length; i++) {
  int start = arr[i];
  int len = 0;
  for (int j = i; j < arr.length; j++) {
    if (arr[j] > start) {
      start = arr[j]
        len++;
    }
  }
  if (len > max) {
    max = len
  }
}
return max

```

这样做的方法的确可以做出结果，但是太丑。

我们来稍微改进一下我们的思维过程，既然讲到动态规划，我们应该想到的是，**能否将问题规模减小**？

一般有很多方法来减小问题规模，比如线性减少，我们考虑把数组规模每次减小一半试试看？ 每次减小一个数字？

我们来试试看第一种思路，即减少一半：

假定我们给一个数组， `[10, 9, 2, 5, 3, 7, 101, 18]`

我们减小一半我们得到两个数组：

- `[10, 9, 2, 5]`
- `[3, 7, 101, 18]`

的确问题的规模变小，但是好像难以找到把子问题的解组合在一起的方法。

我们来看第二种，每次减小一个

我们设计一个

[leetcode 120 三角形路径和](DP/leetcode120.md)

[leetcode 64最小路径和](DP/leetcode64.md)

[Leetcode1314矩阵区域和](DP/leetcode1314.md)

